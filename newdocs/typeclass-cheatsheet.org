* The CheatSheet [view fixed-font, at least 134 chars wide]

TYPE-FAMILIES (with the implicit "kinds"):  

   P[rotocol]                       B[lock]                       L[edger]                     -- P,B,L "kinds"
  ===                              ===                           ===
                                                                                                     +--------+
   p  ──(ConsensusConfig :: P->*)──────────────────────────────────────────────────────────────▶ cc  | static |
   p  ◀──(BlockProtocol :: B->P)─── b ──(BlockConfig :: B->*)──────────────────────────────────▶ bc  | config |
                                    b ──(LedgerState :: B->L)──▶ l ──(LedgerCfg :: L->*)───────▶ lc  | data   |
                                                                                                     +--------+
                                    
                                    b ──(LedgerState :: B->L)──▶ l ──(AuxLedgerEvent :: L->*)──▶ lev   -- events emitted by ledger
                                                                 l ──(LedgerErr :: L->*)───────▶ lerr  -- errors when updating ledger
                                    b ───────────(LedgerConfig :: B->*)────────────────────────▶ lc    -- type syn. for ...
                                    b ───────────(LedgerError  :: B->*)────────────────────────▶ lerr  -- type syn. for ...


                                    b --(CodecConfig   :: B->*)------> codecc -- for serialisation and deserialisation
                                    b --(StorageConfig :: B->*)------> sc     -- other config [?]
                                    b --(Header        :: B->*)------> hdr    -- link block to its header


    p --(ChainDepState :: P->*)--> cds     -- protocol specific state (part that depends on the chain), may rollback
    p --(IsLeader      :: P->*)--> isldr   -- evidence that a node /is/ the leader
    p --(CanBeLeader   :: P->*)--> cbldr   -- evidence that we /can/ be leader
    p --(SelectView    :: P->*)--> selvw   -- projection of header used for chain selection (using `Ord selvw`); often `BlockNo`
    p --(ValidateView  :: P->*)--> valvw   -- projection of header used for header validation (not full block validation)  [[FN1]]
    p --(LedgerView    :: P->*)--> ledvw   -- projection of the ledger state (`l`) required by the protocol
    p --(ValidationErr :: P->*)--> valerr  -- error when adding new header to `cds`

                       s ───(Ticked :: *->*)───▶ s'   -- time related changes applied to some state (`l`, `ledvw`, `cds`)
                                  
TYPE-CLASSES:

 class Ord (SelectView p) => ConsensusProtocol p where
   checkIsLeader         :: cc -> cbldr -> SlotNo -> Ticked cds -> Maybe isldr       -- if we lead this slot, 'Just evidence'
   tickChainDepState     :: cc -> Ticked ledvw -> SlotNo -> cds -> Ticked cds        -- tick the cds to the SlotNo
   updateChainDepState   :: cc -> valvw -> SlotNo -> Ticked cds -> Except valerr cds -- apply header to cds [may error]
   reupdateChainDepState :: cc -> valvw -> SlotNo -> Ticked cds -> cds               -- re-apply header to cds [no error]
   protocolSecurityParam :: cc -> SecurityParam                                      -- get security parameter 'k'

                              class (StandardHash b, Typeable b) => HasHeader b where -- abstract over block headers
                                getHeaderFields :: b -> HeaderFields b    -- i.e., slot, blockno, hash

                              class (HasHeader b, GetHeader b) => GetPrevHash b where   
                                headerPrevHash :: Header b -> ChainHash b  -- get the hash of predecessor
  
                                                class GetTip l where
                                                  getTip :: l → Point l

                                                class (GetTip l, GetTip (Ticked l)) => IsLedger l where
                                                  applyChainTickLedgerResult :: lc → SlotNo → l → LedgerResult l (Ticked l)

                              -- BlockSupportsProtocol b - can we construct the views on block `b` required by protocol `p`
                              class (GetPrevHash b, ConsensusProtocol p) => BlockSupportsProtocol b where              -- [[FN2]]
                                validateView :: bc -> Header b -> ValidateView p  -- project from hdr for hdr validation, [[FN1]]
                                selectView   :: bc -> Header b -> SelectView p    -- project from hdr for chain selection
                                    
  class (IsLedger l, HeaderHash l ~ HeaderHash b, HasHeader b, HasHeader (Header b)) => ApplyBlock l b where
    applyBlockLedgerResult   :: lc -> b -> Ticked l -> Except (LedgerErr l) (LedgerResult l l)  
    reapplyBlockLedgerResult :: lc -> b -> Ticked l -> LedgerResult l l
    
  class ApplyBlock (LedgerState b) b => UpdateLedger b where
    {}

  -- | Link protocol to ledger
  class (BlockSupportsProtocol b, UpdateLedger b, ValidateEnvelope b) => LedgerSupportsProtocol b where
    protocolLedgerView   :: lc -> Ticked l -> Ticked ledvw   -- `ledvw` (`LedgerView (BlockProtocol b)`) extracted from the ledger
    ledgerViewForecastAt :: lc -> l -> Forecast ledvw        -- Get a forecast at the given ledger state.
      
                                                  
* Networking code: some basic definitions

-- | Header fields we expect to be present in a block
--
-- These fields are lazy because they are extracted from a block or block
-- header; this type is not intended for storage.
data HeaderFields b = HeaderFields {
      headerFieldSlot    :: SlotNo
    , headerFieldBlockNo :: BlockNo
    , headerFieldHash    :: HeaderHash b
      -- ^ NOTE: this field is last so that the derived 'Eq' and 'Ord'
      -- instances first compare the slot and block numbers, which is cheaper
      -- than comparing hashes.
    }
  deriving (Generic)

-- | A point on the chain is identified by its 'Slot' and 'HeaderHash'.
--
-- The 'Slot' tells us where to look and the 'HeaderHash' either simply serves
-- as a check, or in some contexts it disambiguates blocks from different forks
-- that were in the same slot.
--
-- It's a newtype rather than a type synonym, because using a type synonym
-- would lead to ambiguity, since HeaderHash is a non-injective type family.
newtype Point block = Point
    { getPoint :: WithOrigin (Point.Block SlotNo (HeaderHash block))
    }
  deriving (Generic)
  
blockHash :: HasHeader b => b -> HeaderHash b
blockHash = headerFieldHash . getHeaderFields

blockSlot :: HasHeader b => b -> SlotNo
blockSlot = headerFieldSlot . getHeaderFields

blockNo   :: HasHeader b => b -> BlockNo
blockNo = headerFieldBlockNo . getHeaderFields

* Diagramatic Conventions

- re P,B,L
  - these are not kinds in the code, but "morally equivalent",  created for the sake of documentation.
  - we use 'p', 'b', and 'l' respectively as type names to refer to elements of the P, B, L kinds
  
- we are not distinguishing associated types from standalone type families.
  
- To reduce the "noise", we are ignoring these type-class constraints:
  - NoThunks, Eq, Show, HasCallStack
  - but not Ord

- variable conventions:
  - when convenient, implicit conversions between type variables and type-functions applied to variables:
 
     p  <==> BlockProtocol b
     cds <==> ChainDepState p
     ...
     
  - confusing or helpful?
    - given 'b' everything else is determined, so no ambiguity
    - wantinng to ignore issues of type inference
    - naming of "applications" may give intuition and does make more concise
    
* Semantic notes/footnotes

- <<FN1>> As a consequence of the header/block split, we want to validate the header as soon as the chain sync client acquires the
  header.  Thus we do not download blocks whose headers fail this validation.  See Ouroboros/Consensus/HeaderValidation.hs in which
  the `validateView` method is called.
  
- <<FN2>> Appears that `GetHeader b` is redundant in BlockSupportsProtocol class.

- <<FN3>> Regarding 'lev': note that `LedgerResult l l` includes 'lev'
  
- Note that 'b' (block) determines the 'l' ledger type.  Note 5.1.1 in [[CCASL:]] "Nonetheless, a ledger can only be used with a single
  type of block, and consequently can only have a single type of error; the only reason block application is defined separately is
  that a single type of block can be used with multiple ledgers (in other words, this is a 1-to-many relationship)."

* TODO improvements/adds

- TODO can you distinguish associated types without the diagram getting *too* busy?
  
- add other key type families
  - =Validated= in **.Ledger.Abstract
  - and
    : b ------------------- (GenTx :: B->*)---> tx  -- generalized transactions
    ...?

    -- 'generalized transactions'?  so what is a non generalized tx?
        NF: possibly an utxo.
    
- other key types?
  =LedgerSupportsMempool blk=
  
- rendering 
  - be consistent: ascii vs unicode arrows & etc
  - group the classes with gray borders
  - ?
    
- make note of the *few* type constructors in the above signatures
  - or put into a separate font?
  
