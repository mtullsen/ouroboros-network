* The CheatSheet [view fixed-font, at least 132 chars wide]

TYPE-FUNCTIONS (with "KINDS"):  

   P[rotocol]                         B[lock]                      L[edger]                     -- P,B,L "kinds"
  ---                                ---                          ---
                                                                                                  +--------+
   p  <---(BlockProtocol :: B->P)---- b --(LedgerState :: B->L)--> l --(LedgerCfg :: L->*)--> lc  | static |
                                      b --(BlockConfig :: B->*)-----------------------------> bc  | config |
   p  --(ConsensusConfig :: P->*)-----------------------------------------------------------> cc  | data   |
                                                                                                  +--------+
                                                                                                  
                                      b --(CodecConfig   :: B->*)------> cc  -- for serialisation and deserialisation
                                      b --(StorageConfig :: B->*)------> sc  -- 
                                      b --(Header        :: B->*)------> hdr

                                      b ------------------- (GenTx :: B->*)---> tx
                                        
    p --(ChainDepState :: P->*)--> cds     -- protocol specific state (part that depends on the chain), may rollback
    p --(IsLeader      :: P->*)--> isldr   -- evidence that a node /is/ the leader
    p --(CanBeLeader   :: P->*)--> cbldr   -- evidence that we /can/ be leader
    p --(SelectView    :: P->*)--> selvw   -- projection of header required to do chain selection (often equals BlockNo)
    p --(ValidateView  :: P->*)--> valvw   -- projection of header required to validate it
    p --(LedgerView    :: P->*)--> ledvw   -- projection of the ledger state ('l') that consensus needs
    p --(ValidationErr :: P->*)--> valerr  -- validation errors

TYPE-CLASSES:

 class ConsensusProtocol p where
   checkIsLeader         :: cc -> cbldr -> SlotNo -> Ticked cds -> Maybe isldr       -- if we lead this slot, 'Just evidence'
   tickChainDepState     :: cc -> Ticked ledvw -> SlotNo -> cds -> Ticked cds        -- tick the cds to the SlotNo
   updateChainDepState   :: cc -> valvw -> SlotNo -> Ticked cds -> Except valerr cds -- apply header to cds [may error]
   reupdateChainDepState :: cc -> valvw -> SlotNo -> Ticked cds -> cds               -- re-apply header to cds [no error]
   protocolSecurityParam :: cc -> SecurityParam                                      -- get security parameter 'k'

   
                              class (GetHeader b, GetPrevHash b, ConsensusProtocol p) => BlockSupportsProtocol b where
                                 validateView :: BlockConfig b -> Header b -> ValidateView p
                                 selectView   :: BlockConfig b -> Header b -> SelectView p


                                                        class GetTip l where
                                                          getTip :: l → Point l

                                                        class (GetTip l,GetTip (Ticked l),LedgerCfg l) => IsLedger l
                                                           where
                                                           applyChainTickLedgerResult ::
                                                             LedgerCfg l → SlotNo → l → LedgerResult l (Ticked l)

* Diagramatic Conventions

- re P,B,L
  - these are not kinds in the code, but "morally equivalent",  created for the sake of documentation.
  - we use 'p', 'b', and 'l' respectively as type names to refer to elements of the P, B, L kinds
  
- we are not distinguishing associated types from standalone type families.
  
- To reduce the "noise", we are ignororing these type-class constraints:
  - NoThunks, Eq, Show, etc.

- variable conventions:
  - when convenient, implicit conversions between type variables and type-functions applied to variables:
 
     p  <==> BlockProtocol b
     cds <==> ChainDepState p
     ...

* Semantic notes/footnotes

- Note that 'b' (block) determines the 'l' ledger type.  Note 5.1.1 in [[CCASL:]] Nonetheless, a ledger can only be used with a single type of block, and consequently can only have a
  single type of error; the only reason block application is defined separately is that a single type of block can be used with multiple ledgers (in other words, this is a 1-to-many relationship).

* TODO add these

- header oriented classes
- other type functions
- see ... in **.Ledger.Abstract
- be consistent: ascii vs unicode arrows & etc
      
