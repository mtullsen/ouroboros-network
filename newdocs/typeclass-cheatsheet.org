* The CheatSheet [view fixed-font, 132 chars wide

TYPE-FUNCTIONS:  

   P[rotocol]                         B[lock]                      L[edger]                     -- three "KINDS"
  ---                                ---                          ---
                                                                                                  +--------+
   p  <---(BlockProtocol :: B->P)---- b --(LedgerState :: B->L)--> l --(LedgerCfg :: L->*)--> lc  | static |
                                      b --(BlockConfig :: B->*)-----------------------------> bc  | config |
   p  --(ConsensusConfig :: P->*)-----------------------------------------------------------> cc  | data   |
                                                                                                  +--------+
                                                                                                  
                                      b --(CodecConfig   :: B->*)----> cc  -- for serialisation and deserialisation
                                      b --(StorageConfig :: B->*)----> sc  -- 
                                      b --(Header        :: B->*)----> hdr

                                      b ------------------- (GenTx b :: B->T)---> tx
                                        
    p --(ChainDepState :: P->*)--> cds
    p --(IsLeader      :: P->*)--> isldr   -- evidence that a node /is/ the leader
    p --(CanBeLeader   :: P->*)--> cbldr   -- evidence that we /can/ be leader
    p --(SelectView    :: P->*)--> selvw   -- projection of header required for chain selection (often BlockNo)
    p --(ValidateView  :: P->*)--> valvw   -- projection of header required to validate it
    p --(LedgerView    :: P->*)--> ledvw   -- projection of the ledger state ('l') that consensus needs
    p --(ValidationErr :: P->*)--> valerr  -- validation errors

TYPE-CLASSES:

class ConsensusProtocol p where
  checkIsLeader         :: cc -> cbldr -> SlotNo -> Ticked cds -> Maybe isldr       -- if leader this slot, 'Just evidence'
  tickChainDepState     :: cc -> Ticked ledvw -> SlotNo -> cds -> Ticked cds        -- tick the cds to the SlotNo
  updateChainDepState   :: cc -> valvw -> SlotNo -> Ticked cds -> Except valerr cds -- apply header to cds [may error]
  reupdateChainDepState :: cc -> valvw -> SlotNo -> Ticked cds -> cds               -- re-apply header to cds [no error]
  protocolSecurityParam :: cc -> SecurityParam                                      -- get 'k'

                             class (GetHeader b, GetPrevHash b, ConsensusProtocol p) => BlockSupportsProtocol b where
                                validateView :: BlockConfig b -> Header b -> ValidateView p
                                selectView   :: BlockConfig b -> Header b -> SelectView p

                                                       class GetTip l where
                                                         getTip :: l → Point l

                                                       class (GetTip l,GetTip (Ticked l),LedgerCfg l) => IsLedger l
                                                          where
                                                          applyChainTickLedgerResult ::
                                                            LedgerCfg l → SlotNo → l → LedgerResult l (Ticked l)

* Diagramatic Conventions

- not distinguishing associated types from standalone type families.
  
- ignoring "noise" from type-classes by removing these type-classes:
  - NoThunks, Eq, Show, etc.

- variable conventions:
  - when convenient, implicit conversions between type variables and type-functions applied to variables:
 
     p  <==> BlockProtocol b
     cds <==> ChainDepState p
     ...

* Semantic notes/footnotes

- Note that 'b' (block) determines the 'l' ledger type.  Note 5.1.1 in [[CCASL:]] Nonetheless, a ledger can only be used with a single type of block, and consequently can only have a
  single type of error; the only reason block application is defined separately is that a single type of block can be used with multiple ledgers (in other words, this is a 1-to-many relationship).

* TODO add these

- header oriented classes
- other type functions
- see ... in Ledger.Abstract
    
